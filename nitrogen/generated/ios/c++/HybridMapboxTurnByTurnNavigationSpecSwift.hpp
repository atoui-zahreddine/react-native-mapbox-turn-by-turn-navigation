///
/// HybridMapboxTurnByTurnNavigationSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridMapboxTurnByTurnNavigationSpec.hpp"

// Forward declaration of `HybridMapboxTurnByTurnNavigationSpec_cxx` to properly resolve imports.
namespace MapboxTurnByTurnNavigation { class HybridMapboxTurnByTurnNavigationSpec_cxx; }

// Forward declaration of `DistanceUnitEnum` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { enum class DistanceUnitEnum; }
// Forward declaration of `Coordinate` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Coordinate; }
// Forward declaration of `TravelModeEnum` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { enum class TravelModeEnum; }
// Forward declaration of `Waypoint` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Waypoint; }
// Forward declaration of `WaypointEvent` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct WaypointEvent; }
// Forward declaration of `LocationData` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct LocationData; }
// Forward declaration of `RouteProgress` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct RouteProgress; }
// Forward declaration of `Message` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Message; }

#include <optional>
#include "DistanceUnitEnum.hpp"
#include "Coordinate.hpp"
#include <string>
#include "TravelModeEnum.hpp"
#include <vector>
#include "Waypoint.hpp"
#include <functional>
#include "WaypointEvent.hpp"
#include "LocationData.hpp"
#include "RouteProgress.hpp"
#include "Message.hpp"

#include "MapboxTurnByTurnNavigation-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::mapboxturnbyturnnavigation {

  /**
   * The C++ part of HybridMapboxTurnByTurnNavigationSpec_cxx.swift.
   *
   * HybridMapboxTurnByTurnNavigationSpecSwift (C++) accesses HybridMapboxTurnByTurnNavigationSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridMapboxTurnByTurnNavigationSpec_cxx can directly inherit from the C++ class HybridMapboxTurnByTurnNavigationSpec
   * to simplify the whole structure and memory management.
   */
  class HybridMapboxTurnByTurnNavigationSpecSwift: public virtual HybridMapboxTurnByTurnNavigationSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridMapboxTurnByTurnNavigationSpecSwift(const MapboxTurnByTurnNavigation::HybridMapboxTurnByTurnNavigationSpec_cxx& swiftPart):
      HybridObject(HybridMapboxTurnByTurnNavigationSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline MapboxTurnByTurnNavigation::HybridMapboxTurnByTurnNavigationSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    // Get memory pressure
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }

  public:
    // Properties
    inline std::optional<bool> getMute() noexcept override {
      auto __result = _swiftPart.getMute();
      return __result;
    }
    inline void setMute(std::optional<bool> mute) noexcept override {
      _swiftPart.setMute(mute);
    }
    inline std::optional<DistanceUnitEnum> getDistanceUnit() noexcept override {
      auto __result = _swiftPart.getDistanceUnit();
      return __result;
    }
    inline void setDistanceUnit(std::optional<DistanceUnitEnum> distanceUnit) noexcept override {
      _swiftPart.setDistanceUnit(distanceUnit);
    }
    inline Coordinate getOrigin() noexcept override {
      auto __result = _swiftPart.getOrigin();
      return __result;
    }
    inline void setOrigin(const Coordinate& origin) noexcept override {
      _swiftPart.setOrigin(origin);
    }
    inline std::optional<std::string> getDestinationTitle() noexcept override {
      auto __result = _swiftPart.getDestinationTitle();
      return __result;
    }
    inline void setDestinationTitle(const std::optional<std::string>& destinationTitle) noexcept override {
      _swiftPart.setDestinationTitle(destinationTitle);
    }
    inline Coordinate getDestination() noexcept override {
      auto __result = _swiftPart.getDestination();
      return __result;
    }
    inline void setDestination(const Coordinate& destination) noexcept override {
      _swiftPart.setDestination(destination);
    }
    inline std::optional<std::string> getLanguage() noexcept override {
      auto __result = _swiftPart.getLanguage();
      return __result;
    }
    inline void setLanguage(const std::optional<std::string>& language) noexcept override {
      _swiftPart.setLanguage(language);
    }
    inline std::optional<TravelModeEnum> getTravelMode() noexcept override {
      auto __result = _swiftPart.getTravelMode();
      return __result;
    }
    inline void setTravelMode(std::optional<TravelModeEnum> travelMode) noexcept override {
      _swiftPart.setTravelMode(travelMode);
    }
    inline std::optional<bool> getShouldSimulateRoute() noexcept override {
      auto __result = _swiftPart.getShouldSimulateRoute();
      return __result;
    }
    inline void setShouldSimulateRoute(std::optional<bool> shouldSimulateRoute) noexcept override {
      _swiftPart.setShouldSimulateRoute(shouldSimulateRoute);
    }
    inline std::optional<std::vector<Waypoint>> getWaypoints() noexcept override {
      auto __result = _swiftPart.getWaypoints();
      return __result;
    }
    inline void setWaypoints(const std::optional<std::vector<Waypoint>>& waypoints) noexcept override {
      _swiftPart.setWaypoints(waypoints);
    }
    inline std::optional<bool> getShowsEndOfRouteFeedback() noexcept override {
      auto __result = _swiftPart.getShowsEndOfRouteFeedback();
      return __result;
    }
    inline void setShowsEndOfRouteFeedback(std::optional<bool> showsEndOfRouteFeedback) noexcept override {
      _swiftPart.setShowsEndOfRouteFeedback(showsEndOfRouteFeedback);
    }
    inline std::optional<bool> getShowCancelButton() noexcept override {
      auto __result = _swiftPart.getShowCancelButton();
      return __result;
    }
    inline void setShowCancelButton(std::optional<bool> showCancelButton) noexcept override {
      _swiftPart.setShowCancelButton(showCancelButton);
    }
    inline std::optional<bool> getHideStatusView() noexcept override {
      auto __result = _swiftPart.getHideStatusView();
      return __result;
    }
    inline void setHideStatusView(std::optional<bool> hideStatusView) noexcept override {
      _swiftPart.setHideStatusView(hideStatusView);
    }

  public:
    // Methods
    inline std::function<void()> addOnWaypointArrivalListener(const std::function<void(const WaypointEvent& /* event */)>& listener) override {
      auto __result = _swiftPart.addOnWaypointArrivalListener(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> addOnArrivalListener(const std::function<void(const Coordinate& /* event */)>& listener) override {
      auto __result = _swiftPart.addOnArrivalListener(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> addOnLocationChangeListener(const std::function<void(const LocationData& /* event */)>& listener) override {
      auto __result = _swiftPart.addOnLocationChangeListener(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> addOnRouteProgressChangeListener(const std::function<void(const RouteProgress& /* event */)>& listener) override {
      auto __result = _swiftPart.addOnRouteProgressChangeListener(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> addOnCancelListener(const std::function<void()>& listener) override {
      auto __result = _swiftPart.addOnCancelListener(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::function<void()> addOnErrorListener(const std::function<void(const Message& /* error */)>& listener) override {
      auto __result = _swiftPart.addOnErrorListener(listener);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }

  private:
    MapboxTurnByTurnNavigation::HybridMapboxTurnByTurnNavigationSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::mapboxturnbyturnnavigation
