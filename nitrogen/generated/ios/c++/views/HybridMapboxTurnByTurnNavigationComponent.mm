///
/// HybridMapboxTurnByTurnNavigationComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#import "HybridMapboxTurnByTurnNavigationComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridMapboxTurnByTurnNavigationSpecSwift.hpp"
#import "MapboxTurnByTurnNavigation-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::mapboxturnbyturnnavigation;
using namespace margelo::nitro::mapboxturnbyturnnavigation::views;

/**
 * Represents the React Native View holder for the Nitro "MapboxTurnByTurnNavigation" HybridView.
 */
@interface HybridMapboxTurnByTurnNavigationComponent: RCTViewComponentView
@end

@implementation HybridMapboxTurnByTurnNavigationComponent {
  std::shared_ptr<HybridMapboxTurnByTurnNavigationSpecSwift> _hybridView;
}

+ (void) load {
  [super load];
  [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridMapboxTurnByTurnNavigationComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
  return react::concreteComponentDescriptorProvider<HybridMapboxTurnByTurnNavigationComponentDescriptor>();
}

- (instancetype) init {
  if (self = [super init]) {
    std::shared_ptr<HybridMapboxTurnByTurnNavigationSpec> hybridView = MapboxTurnByTurnNavigation::MapboxTurnByTurnNavigationAutolinking::createMapboxTurnByTurnNavigation();
    _hybridView = std::dynamic_pointer_cast<HybridMapboxTurnByTurnNavigationSpecSwift>(hybridView);
    [self updateView];
  }
  return self;
}

- (void) updateView {
  // 1. Get Swift part
  MapboxTurnByTurnNavigation::HybridMapboxTurnByTurnNavigationSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Get UIView*
  void* viewUnsafe = swiftPart.getView();
  UIView* view = (__bridge_transfer UIView*) viewUnsafe;

  // 3. Update RCTViewComponentView's [contentView]
  [self setContentView:view];
}

- (void) updateProps:(const react::Props::Shared&)props
            oldProps:(const react::Props::Shared&)oldProps {
  // 1. Downcast props
  const auto& newViewPropsConst = *std::static_pointer_cast<HybridMapboxTurnByTurnNavigationProps const>(props);
  auto& newViewProps = const_cast<HybridMapboxTurnByTurnNavigationProps&>(newViewPropsConst);
  MapboxTurnByTurnNavigation::HybridMapboxTurnByTurnNavigationSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Update each prop individually
  swiftPart.beforeUpdate();

  // mute: optional
  if (newViewProps.mute.isDirty) {
    swiftPart.setMute(newViewProps.mute.value);
    newViewProps.mute.isDirty = false;
  }
  // distanceUnit: optional
  if (newViewProps.distanceUnit.isDirty) {
    swiftPart.setDistanceUnit(newViewProps.distanceUnit.value);
    newViewProps.distanceUnit.isDirty = false;
  }
  // origin: struct
  if (newViewProps.origin.isDirty) {
    swiftPart.setOrigin(newViewProps.origin.value);
    newViewProps.origin.isDirty = false;
  }
  // destinationTitle: optional
  if (newViewProps.destinationTitle.isDirty) {
    swiftPart.setDestinationTitle(newViewProps.destinationTitle.value);
    newViewProps.destinationTitle.isDirty = false;
  }
  // destination: struct
  if (newViewProps.destination.isDirty) {
    swiftPart.setDestination(newViewProps.destination.value);
    newViewProps.destination.isDirty = false;
  }
  // language: optional
  if (newViewProps.language.isDirty) {
    swiftPart.setLanguage(newViewProps.language.value);
    newViewProps.language.isDirty = false;
  }
  // travelMode: optional
  if (newViewProps.travelMode.isDirty) {
    swiftPart.setTravelMode(newViewProps.travelMode.value);
    newViewProps.travelMode.isDirty = false;
  }
  // shouldSimulateRoute: optional
  if (newViewProps.shouldSimulateRoute.isDirty) {
    swiftPart.setShouldSimulateRoute(newViewProps.shouldSimulateRoute.value);
    newViewProps.shouldSimulateRoute.isDirty = false;
  }
  // waypoints: optional
  if (newViewProps.waypoints.isDirty) {
    swiftPart.setWaypoints(newViewProps.waypoints.value);
    newViewProps.waypoints.isDirty = false;
  }
  // showsEndOfRouteFeedback: optional
  if (newViewProps.showsEndOfRouteFeedback.isDirty) {
    swiftPart.setShowsEndOfRouteFeedback(newViewProps.showsEndOfRouteFeedback.value);
    newViewProps.showsEndOfRouteFeedback.isDirty = false;
  }
  // showCancelButton: optional
  if (newViewProps.showCancelButton.isDirty) {
    swiftPart.setShowCancelButton(newViewProps.showCancelButton.value);
    newViewProps.showCancelButton.isDirty = false;
  }
  // hideStatusView: optional
  if (newViewProps.hideStatusView.isDirty) {
    swiftPart.setHideStatusView(newViewProps.hideStatusView.value);
    newViewProps.hideStatusView.isDirty = false;
  }

  swiftPart.afterUpdate();

  // 3. Update hybridRef if it changed
  if (newViewProps.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = newViewProps.hybridRef.value;
    if (maybeFunc.has_value()) {
      maybeFunc.value()(_hybridView);
    }
    newViewProps.hybridRef.isDirty = false;
  }

  // 4. Continue in base class
  [super updateProps:props oldProps:oldProps];
}

@end
