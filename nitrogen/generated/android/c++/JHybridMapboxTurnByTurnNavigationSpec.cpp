///
/// JHybridMapboxTurnByTurnNavigationSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridMapboxTurnByTurnNavigationSpec.hpp"

// Forward declaration of `DistanceUnitEnum` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { enum class DistanceUnitEnum; }
// Forward declaration of `Coordinate` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Coordinate; }
// Forward declaration of `TravelModeEnum` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { enum class TravelModeEnum; }
// Forward declaration of `Waypoint` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Waypoint; }
// Forward declaration of `WaypointEvent` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct WaypointEvent; }
// Forward declaration of `LocationData` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct LocationData; }
// Forward declaration of `RouteProgress` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct RouteProgress; }
// Forward declaration of `Message` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Message; }

#include <optional>
#include "DistanceUnitEnum.hpp"
#include "JDistanceUnitEnum.hpp"
#include "Coordinate.hpp"
#include "JCoordinate.hpp"
#include <string>
#include "TravelModeEnum.hpp"
#include "JTravelModeEnum.hpp"
#include <vector>
#include "Waypoint.hpp"
#include "JWaypoint.hpp"
#include <functional>
#include "JFunc_void.hpp"
#include "WaypointEvent.hpp"
#include "JFunc_void_WaypointEvent.hpp"
#include "JWaypointEvent.hpp"
#include "JFunc_void_Coordinate.hpp"
#include "LocationData.hpp"
#include "JFunc_void_LocationData.hpp"
#include "JLocationData.hpp"
#include "RouteProgress.hpp"
#include "JFunc_void_RouteProgress.hpp"
#include "JRouteProgress.hpp"
#include "Message.hpp"
#include "JFunc_void_Message.hpp"
#include "JMessage.hpp"

namespace margelo::nitro::mapboxturnbyturnnavigation {

  jni::local_ref<JHybridMapboxTurnByTurnNavigationSpec::jhybriddata> JHybridMapboxTurnByTurnNavigationSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridMapboxTurnByTurnNavigationSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridMapboxTurnByTurnNavigationSpec::initHybrid),
    });
  }

  size_t JHybridMapboxTurnByTurnNavigationSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  // Properties
  std::optional<bool> JHybridMapboxTurnByTurnNavigationSpec::getMute() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getMute");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setMute(std::optional<bool> mute) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* mute */)>("setMute");
    method(_javaPart, mute.has_value() ? jni::JBoolean::valueOf(mute.value()) : nullptr);
  }
  std::optional<DistanceUnitEnum> JHybridMapboxTurnByTurnNavigationSpec::getDistanceUnit() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JDistanceUnitEnum>()>("getDistanceUnit");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setDistanceUnit(std::optional<DistanceUnitEnum> distanceUnit) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JDistanceUnitEnum> /* distanceUnit */)>("setDistanceUnit");
    method(_javaPart, distanceUnit.has_value() ? JDistanceUnitEnum::fromCpp(distanceUnit.value()) : nullptr);
  }
  Coordinate JHybridMapboxTurnByTurnNavigationSpec::getOrigin() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JCoordinate>()>("getOrigin");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setOrigin(const Coordinate& origin) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JCoordinate> /* origin */)>("setOrigin");
    method(_javaPart, JCoordinate::fromCpp(origin));
  }
  std::optional<std::string> JHybridMapboxTurnByTurnNavigationSpec::getDestinationTitle() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getDestinationTitle");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setDestinationTitle(const std::optional<std::string>& destinationTitle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* destinationTitle */)>("setDestinationTitle");
    method(_javaPart, destinationTitle.has_value() ? jni::make_jstring(destinationTitle.value()) : nullptr);
  }
  Coordinate JHybridMapboxTurnByTurnNavigationSpec::getDestination() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JCoordinate>()>("getDestination");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setDestination(const Coordinate& destination) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JCoordinate> /* destination */)>("setDestination");
    method(_javaPart, JCoordinate::fromCpp(destination));
  }
  std::optional<std::string> JHybridMapboxTurnByTurnNavigationSpec::getLanguage() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getLanguage");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setLanguage(const std::optional<std::string>& language) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* language */)>("setLanguage");
    method(_javaPart, language.has_value() ? jni::make_jstring(language.value()) : nullptr);
  }
  std::optional<TravelModeEnum> JHybridMapboxTurnByTurnNavigationSpec::getTravelMode() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTravelModeEnum>()>("getTravelMode");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setTravelMode(std::optional<TravelModeEnum> travelMode) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JTravelModeEnum> /* travelMode */)>("setTravelMode");
    method(_javaPart, travelMode.has_value() ? JTravelModeEnum::fromCpp(travelMode.value()) : nullptr);
  }
  std::optional<bool> JHybridMapboxTurnByTurnNavigationSpec::getShouldSimulateRoute() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getShouldSimulateRoute");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setShouldSimulateRoute(std::optional<bool> shouldSimulateRoute) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* shouldSimulateRoute */)>("setShouldSimulateRoute");
    method(_javaPart, shouldSimulateRoute.has_value() ? jni::JBoolean::valueOf(shouldSimulateRoute.value()) : nullptr);
  }
  std::optional<std::vector<Waypoint>> JHybridMapboxTurnByTurnNavigationSpec::getWaypoints() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JWaypoint>>()>("getWaypoints");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<Waypoint> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setWaypoints(const std::optional<std::vector<Waypoint>>& waypoints) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JWaypoint>> /* waypoints */)>("setWaypoints");
    method(_javaPart, waypoints.has_value() ? [&]() {
      size_t __size = waypoints.value().size();
      jni::local_ref<jni::JArrayClass<JWaypoint>> __array = jni::JArrayClass<JWaypoint>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = waypoints.value()[__i];
        __array->setElement(__i, *JWaypoint::fromCpp(__element));
      }
      return __array;
    }() : nullptr);
  }
  std::optional<bool> JHybridMapboxTurnByTurnNavigationSpec::getShowsEndOfRouteFeedback() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getShowsEndOfRouteFeedback");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setShowsEndOfRouteFeedback(std::optional<bool> showsEndOfRouteFeedback) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* showsEndOfRouteFeedback */)>("setShowsEndOfRouteFeedback");
    method(_javaPart, showsEndOfRouteFeedback.has_value() ? jni::JBoolean::valueOf(showsEndOfRouteFeedback.value()) : nullptr);
  }
  std::optional<bool> JHybridMapboxTurnByTurnNavigationSpec::getShowCancelButton() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getShowCancelButton");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setShowCancelButton(std::optional<bool> showCancelButton) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* showCancelButton */)>("setShowCancelButton");
    method(_javaPart, showCancelButton.has_value() ? jni::JBoolean::valueOf(showCancelButton.value()) : nullptr);
  }
  std::optional<bool> JHybridMapboxTurnByTurnNavigationSpec::getHideStatusView() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getHideStatusView");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridMapboxTurnByTurnNavigationSpec::setHideStatusView(std::optional<bool> hideStatusView) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* hideStatusView */)>("setHideStatusView");
    method(_javaPart, hideStatusView.has_value() ? jni::JBoolean::valueOf(hideStatusView.value()) : nullptr);
  }

  // Methods
  std::function<void()> JHybridMapboxTurnByTurnNavigationSpec::addOnWaypointArrivalListener(const std::function<void(const WaypointEvent& /* event */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>(jni::alias_ref<JFunc_void_WaypointEvent::javaobject> /* listener */)>("addOnWaypointArrivalListener_cxx");
    auto __result = method(_javaPart, JFunc_void_WaypointEvent_cxx::fromCpp(listener));
    return [&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }();
  }
  std::function<void()> JHybridMapboxTurnByTurnNavigationSpec::addOnArrivalListener(const std::function<void(const Coordinate& /* event */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>(jni::alias_ref<JFunc_void_Coordinate::javaobject> /* listener */)>("addOnArrivalListener_cxx");
    auto __result = method(_javaPart, JFunc_void_Coordinate_cxx::fromCpp(listener));
    return [&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }();
  }
  std::function<void()> JHybridMapboxTurnByTurnNavigationSpec::addOnLocationChangeListener(const std::function<void(const LocationData& /* event */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>(jni::alias_ref<JFunc_void_LocationData::javaobject> /* listener */)>("addOnLocationChangeListener_cxx");
    auto __result = method(_javaPart, JFunc_void_LocationData_cxx::fromCpp(listener));
    return [&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }();
  }
  std::function<void()> JHybridMapboxTurnByTurnNavigationSpec::addOnRouteProgressChangeListener(const std::function<void(const RouteProgress& /* event */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>(jni::alias_ref<JFunc_void_RouteProgress::javaobject> /* listener */)>("addOnRouteProgressChangeListener_cxx");
    auto __result = method(_javaPart, JFunc_void_RouteProgress_cxx::fromCpp(listener));
    return [&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }();
  }
  std::function<void()> JHybridMapboxTurnByTurnNavigationSpec::addOnCancelListener(const std::function<void()>& listener) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>(jni::alias_ref<JFunc_void::javaobject> /* listener */)>("addOnCancelListener_cxx");
    auto __result = method(_javaPart, JFunc_void_cxx::fromCpp(listener));
    return [&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }();
  }
  std::function<void()> JHybridMapboxTurnByTurnNavigationSpec::addOnErrorListener(const std::function<void(const Message& /* error */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>(jni::alias_ref<JFunc_void_Message::javaobject> /* listener */)>("addOnErrorListener_cxx");
    auto __result = method(_javaPart, JFunc_void_Message_cxx::fromCpp(listener));
    return [&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }();
  }

} // namespace margelo::nitro::mapboxturnbyturnnavigation
