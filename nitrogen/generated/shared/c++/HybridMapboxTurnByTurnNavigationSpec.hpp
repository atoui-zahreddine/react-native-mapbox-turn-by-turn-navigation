///
/// HybridMapboxTurnByTurnNavigationSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `DistanceUnitEnum` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { enum class DistanceUnitEnum; }
// Forward declaration of `Coordinate` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Coordinate; }
// Forward declaration of `TravelModeEnum` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { enum class TravelModeEnum; }
// Forward declaration of `Waypoint` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Waypoint; }
// Forward declaration of `WaypointEvent` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct WaypointEvent; }
// Forward declaration of `LocationData` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct LocationData; }
// Forward declaration of `RouteProgress` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct RouteProgress; }
// Forward declaration of `Message` to properly resolve imports.
namespace margelo::nitro::mapboxturnbyturnnavigation { struct Message; }

#include <optional>
#include "DistanceUnitEnum.hpp"
#include "Coordinate.hpp"
#include <string>
#include "TravelModeEnum.hpp"
#include <vector>
#include "Waypoint.hpp"
#include <functional>
#include "WaypointEvent.hpp"
#include "LocationData.hpp"
#include "RouteProgress.hpp"
#include "Message.hpp"

namespace margelo::nitro::mapboxturnbyturnnavigation {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `MapboxTurnByTurnNavigation`
   * Inherit this class to create instances of `HybridMapboxTurnByTurnNavigationSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridMapboxTurnByTurnNavigation: public HybridMapboxTurnByTurnNavigationSpec {
   * public:
   *   HybridMapboxTurnByTurnNavigation(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridMapboxTurnByTurnNavigationSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridMapboxTurnByTurnNavigationSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridMapboxTurnByTurnNavigationSpec() override = default;

    public:
      // Properties
      virtual std::optional<bool> getMute() = 0;
      virtual void setMute(std::optional<bool> mute) = 0;
      virtual std::optional<DistanceUnitEnum> getDistanceUnit() = 0;
      virtual void setDistanceUnit(std::optional<DistanceUnitEnum> distanceUnit) = 0;
      virtual Coordinate getOrigin() = 0;
      virtual void setOrigin(const Coordinate& origin) = 0;
      virtual std::optional<std::string> getDestinationTitle() = 0;
      virtual void setDestinationTitle(const std::optional<std::string>& destinationTitle) = 0;
      virtual Coordinate getDestination() = 0;
      virtual void setDestination(const Coordinate& destination) = 0;
      virtual std::optional<std::string> getLanguage() = 0;
      virtual void setLanguage(const std::optional<std::string>& language) = 0;
      virtual std::optional<TravelModeEnum> getTravelMode() = 0;
      virtual void setTravelMode(std::optional<TravelModeEnum> travelMode) = 0;
      virtual std::optional<bool> getShouldSimulateRoute() = 0;
      virtual void setShouldSimulateRoute(std::optional<bool> shouldSimulateRoute) = 0;
      virtual std::optional<std::vector<Waypoint>> getWaypoints() = 0;
      virtual void setWaypoints(const std::optional<std::vector<Waypoint>>& waypoints) = 0;
      virtual std::optional<bool> getShowsEndOfRouteFeedback() = 0;
      virtual void setShowsEndOfRouteFeedback(std::optional<bool> showsEndOfRouteFeedback) = 0;
      virtual std::optional<bool> getShowCancelButton() = 0;
      virtual void setShowCancelButton(std::optional<bool> showCancelButton) = 0;
      virtual std::optional<bool> getHideStatusView() = 0;
      virtual void setHideStatusView(std::optional<bool> hideStatusView) = 0;

    public:
      // Methods
      virtual std::function<void()> addOnWaypointArrivalListener(const std::function<void(const WaypointEvent& /* event */)>& listener) = 0;
      virtual std::function<void()> addOnArrivalListener(const std::function<void(const Coordinate& /* event */)>& listener) = 0;
      virtual std::function<void()> addOnLocationChangeListener(const std::function<void(const LocationData& /* event */)>& listener) = 0;
      virtual std::function<void()> addOnRouteProgressChangeListener(const std::function<void(const RouteProgress& /* event */)>& listener) = 0;
      virtual std::function<void()> addOnCancelListener(const std::function<void()>& listener) = 0;
      virtual std::function<void()> addOnErrorListener(const std::function<void(const Message& /* error */)>& listener) = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "MapboxTurnByTurnNavigation";
  };

} // namespace margelo::nitro::mapboxturnbyturnnavigation
